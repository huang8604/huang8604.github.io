<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Android13 BufferQueueLayer UpdateTexImage流程分析-CSDN博客 - 文韬的文档</title><meta name=author content="wentao"><meta name=description content="BufferQueueLayer的updateTexImage方法用于将当前图形缓冲区的内容更新到纹理中，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp status_t BufferQueueLayer::updateTexImage(bool& recomputeVisibleRegions, nsecs_t latchTime, nsecs_t expectedPresentTime) { // This boolean is used to make sure that SurfaceFlinger's shadow copy // of the buffer queue isn't modified when the buffer queue is returning // BufferItem's that weren't actually queued. This can happen in shared // buffer mode. bool queuedBuffer = false; const int32_t layerId = getSequence(); LayerRejecter r(mDrawingState, getDrawingState(), recomputeVisibleRegions, getProducerStickyTransform() != 0, mName, getTransformToDisplayInverse()); if (isRemovedFromCurrentState()) { expectedPresentTime = 0; } // updateTexImage() below might drop the some buffers at the head of the queue if there is a // buffer behind them which is timely to be presented. However this buffer may not be signaled // yet. The code below makes sure that this wouldn't happen by setting maxFrameNumber to the // last buffer that was signaled. uint64_t lastSignaledFrameNumber = mLastFrameNumberReceived; { Mutex::Autolock lock(mQueueItemLock); for (size_t i = 0; i < mQueueItems.size(); i++) { bool fenceSignaled = mQueueItems[i].item.mFenceTime->getSignalTime() != Fence::SIGNAL_TIME_PENDING; if (!fenceSignaled) { break; } lastSignaledFrameNumber = mQueueItems[i].item.mFrameNumber; } } const uint64_t maxFrameNumberToAcquire = std::min(mLastFrameNumberReceived.load(), lastSignaledFrameNumber); bool autoRefresh; status_t updateResult = mConsumer->updateTexImage(&amp;r, expectedPresentTime, &amp;autoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire); mDrawingState.autoRefresh = autoRefresh; if (updateResult == BufferQueue::PRESENT_LATER) { // Producer doesn't want buffer to be displayed yet. Signal a // layer update so we check again at the next opportunity. // Producer 不希望显示缓冲区。 发出图层更新的信号，以便我们在下次有机会时再次检查。 mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 return BAD_VALUE; } else if (updateResult == BufferLayerConsumer::BUFFER_REJECTED) { // If the buffer has been rejected, remove it from the shadow queue // and return early if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); if (mQueuedFrames > 0) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } } return BAD_VALUE; } else if (updateResult != NO_ERROR || mUpdateTexImageFailed) { // This can occur if something goes wrong when trying to create the // EGLImage for this buffer. If this happens, the buffer has already // been released, so we need to clean up the queue and bug out // early. if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); for (auto& [item, surfaceFrame] : mQueueItems) { if (surfaceFrame) { addSurfaceFrameDroppedForBuffer(surfaceFrame); } } mQueueItems.clear(); mQueuedFrames = 0; mFlinger->mTimeStats->onDestroy(layerId); mFlinger->mFrameTracer->onDestroy(layerId); } // Once we have hit this state, the shadow queue may no longer // correctly reflect the incoming BufferQueue's contents, so even if // updateTexImage starts working, the only safe course of action is // to continue to ignore updates. mUpdateTexImageFailed = true; return BAD_VALUE; } bool more_frames_pending = false; if (queuedBuffer) { // Autolock scope auto currentFrameNumber = mConsumer->getFrameNumber(); Mutex::Autolock lock(mQueueItemLock); // Remove any stale buffers that have been dropped during // updateTexImage while (mQueuedFrames > 0 && mQueueItems[0].item.mFrameNumber != currentFrameNumber) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } uint64_t bufferID = mQueueItems[0].item.mGraphicBuffer->getId(); mFlinger->mTimeStats->setLatchTime(layerId, currentFrameNumber, latchTime); mFlinger->mFrameTracer->traceTimestamp(layerId, bufferID, currentFrameNumber, latchTime, FrameTracer::FrameEvent::LATCH); if (mQueueItems[0].surfaceFrame) { addSurfaceFramePresentedForBuffer(mQueueItems[0].surfaceFrame, mQueueItems[0].item.mFenceTime->getSignalTime(), latchTime); } mQueueItems.erase(mQueueItems.begin()); more_frames_pending = (mQueuedFrames.fetch_sub(1) > 1); } // Decrement the queued-frames count. Signal another event if we // have more frames pending. //减少排队的帧计数。 如果我们有更多待处理的帧，则发出另一个事件的信号。 if ((queuedBuffer && more_frames_pending) || mDrawingState.autoRefresh) { mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 | 知识管理 - PingCode } return NO_ERROR; } BufferLayerConsumer updateTexImage 调用BufferLayerConsumer的updateTexImage方法：
"><meta name=keywords content='clippings,转载,blog'><meta itemprop=name content="Android13 BufferQueueLayer updateTexImage流程分析-CSDN博客"><meta itemprop=description content="BufferQueueLayer的updateTexImage方法用于将当前图形缓冲区的内容更新到纹理中，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp status_t BufferQueueLayer::updateTexImage(bool& recomputeVisibleRegions, nsecs_t latchTime, nsecs_t expectedPresentTime) { // This boolean is used to make sure that SurfaceFlinger's shadow copy // of the buffer queue isn't modified when the buffer queue is returning // BufferItem's that weren't actually queued. This can happen in shared // buffer mode. bool queuedBuffer = false; const int32_t layerId = getSequence(); LayerRejecter r(mDrawingState, getDrawingState(), recomputeVisibleRegions, getProducerStickyTransform() != 0, mName, getTransformToDisplayInverse()); if (isRemovedFromCurrentState()) { expectedPresentTime = 0; } // updateTexImage() below might drop the some buffers at the head of the queue if there is a // buffer behind them which is timely to be presented. However this buffer may not be signaled // yet. The code below makes sure that this wouldn't happen by setting maxFrameNumber to the // last buffer that was signaled. uint64_t lastSignaledFrameNumber = mLastFrameNumberReceived; { Mutex::Autolock lock(mQueueItemLock); for (size_t i = 0; i < mQueueItems.size(); i++) { bool fenceSignaled = mQueueItems[i].item.mFenceTime->getSignalTime() != Fence::SIGNAL_TIME_PENDING; if (!fenceSignaled) { break; } lastSignaledFrameNumber = mQueueItems[i].item.mFrameNumber; } } const uint64_t maxFrameNumberToAcquire = std::min(mLastFrameNumberReceived.load(), lastSignaledFrameNumber); bool autoRefresh; status_t updateResult = mConsumer->updateTexImage(&amp;r, expectedPresentTime, &amp;autoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire); mDrawingState.autoRefresh = autoRefresh; if (updateResult == BufferQueue::PRESENT_LATER) { // Producer doesn't want buffer to be displayed yet. Signal a // layer update so we check again at the next opportunity. // Producer 不希望显示缓冲区。 发出图层更新的信号，以便我们在下次有机会时再次检查。 mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 return BAD_VALUE; } else if (updateResult == BufferLayerConsumer::BUFFER_REJECTED) { // If the buffer has been rejected, remove it from the shadow queue // and return early if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); if (mQueuedFrames > 0) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } } return BAD_VALUE; } else if (updateResult != NO_ERROR || mUpdateTexImageFailed) { // This can occur if something goes wrong when trying to create the // EGLImage for this buffer. If this happens, the buffer has already // been released, so we need to clean up the queue and bug out // early. if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); for (auto& [item, surfaceFrame] : mQueueItems) { if (surfaceFrame) { addSurfaceFrameDroppedForBuffer(surfaceFrame); } } mQueueItems.clear(); mQueuedFrames = 0; mFlinger->mTimeStats->onDestroy(layerId); mFlinger->mFrameTracer->onDestroy(layerId); } // Once we have hit this state, the shadow queue may no longer // correctly reflect the incoming BufferQueue's contents, so even if // updateTexImage starts working, the only safe course of action is // to continue to ignore updates. mUpdateTexImageFailed = true; return BAD_VALUE; } bool more_frames_pending = false; if (queuedBuffer) { // Autolock scope auto currentFrameNumber = mConsumer->getFrameNumber(); Mutex::Autolock lock(mQueueItemLock); // Remove any stale buffers that have been dropped during // updateTexImage while (mQueuedFrames > 0 && mQueueItems[0].item.mFrameNumber != currentFrameNumber) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } uint64_t bufferID = mQueueItems[0].item.mGraphicBuffer->getId(); mFlinger->mTimeStats->setLatchTime(layerId, currentFrameNumber, latchTime); mFlinger->mFrameTracer->traceTimestamp(layerId, bufferID, currentFrameNumber, latchTime, FrameTracer::FrameEvent::LATCH); if (mQueueItems[0].surfaceFrame) { addSurfaceFramePresentedForBuffer(mQueueItems[0].surfaceFrame, mQueueItems[0].item.mFenceTime->getSignalTime(), latchTime); } mQueueItems.erase(mQueueItems.begin()); more_frames_pending = (mQueuedFrames.fetch_sub(1) > 1); } // Decrement the queued-frames count. Signal another event if we // have more frames pending. //减少排队的帧计数。 如果我们有更多待处理的帧，则发出另一个事件的信号。 if ((queuedBuffer && more_frames_pending) || mDrawingState.autoRefresh) { mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 | 知识管理 - PingCode } return NO_ERROR; } BufferLayerConsumer updateTexImage 调用BufferLayerConsumer的updateTexImage方法："><meta itemprop=datePublished content="2024-11-06T06:57:52+00:00"><meta itemprop=dateModified content="2024-12-27T14:50:21+00:00"><meta itemprop=wordCount content="2903"><meta itemprop=keywords content="Clippings,转载,Blog"><meta property="og:url" content="https://huang8604.github.io/posts/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/"><meta property="og:site_name" content="文韬的文档"><meta property="og:title" content="Android13 BufferQueueLayer updateTexImage流程分析-CSDN博客"><meta property="og:description" content="BufferQueueLayer的updateTexImage方法用于将当前图形缓冲区的内容更新到纹理中，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp status_t BufferQueueLayer::updateTexImage(bool& recomputeVisibleRegions, nsecs_t latchTime, nsecs_t expectedPresentTime) { // This boolean is used to make sure that SurfaceFlinger's shadow copy // of the buffer queue isn't modified when the buffer queue is returning // BufferItem's that weren't actually queued. This can happen in shared // buffer mode. bool queuedBuffer = false; const int32_t layerId = getSequence(); LayerRejecter r(mDrawingState, getDrawingState(), recomputeVisibleRegions, getProducerStickyTransform() != 0, mName, getTransformToDisplayInverse()); if (isRemovedFromCurrentState()) { expectedPresentTime = 0; } // updateTexImage() below might drop the some buffers at the head of the queue if there is a // buffer behind them which is timely to be presented. However this buffer may not be signaled // yet. The code below makes sure that this wouldn't happen by setting maxFrameNumber to the // last buffer that was signaled. uint64_t lastSignaledFrameNumber = mLastFrameNumberReceived; { Mutex::Autolock lock(mQueueItemLock); for (size_t i = 0; i < mQueueItems.size(); i++) { bool fenceSignaled = mQueueItems[i].item.mFenceTime->getSignalTime() != Fence::SIGNAL_TIME_PENDING; if (!fenceSignaled) { break; } lastSignaledFrameNumber = mQueueItems[i].item.mFrameNumber; } } const uint64_t maxFrameNumberToAcquire = std::min(mLastFrameNumberReceived.load(), lastSignaledFrameNumber); bool autoRefresh; status_t updateResult = mConsumer->updateTexImage(&amp;r, expectedPresentTime, &amp;autoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire); mDrawingState.autoRefresh = autoRefresh; if (updateResult == BufferQueue::PRESENT_LATER) { // Producer doesn't want buffer to be displayed yet. Signal a // layer update so we check again at the next opportunity. // Producer 不希望显示缓冲区。 发出图层更新的信号，以便我们在下次有机会时再次检查。 mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 return BAD_VALUE; } else if (updateResult == BufferLayerConsumer::BUFFER_REJECTED) { // If the buffer has been rejected, remove it from the shadow queue // and return early if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); if (mQueuedFrames > 0) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } } return BAD_VALUE; } else if (updateResult != NO_ERROR || mUpdateTexImageFailed) { // This can occur if something goes wrong when trying to create the // EGLImage for this buffer. If this happens, the buffer has already // been released, so we need to clean up the queue and bug out // early. if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); for (auto& [item, surfaceFrame] : mQueueItems) { if (surfaceFrame) { addSurfaceFrameDroppedForBuffer(surfaceFrame); } } mQueueItems.clear(); mQueuedFrames = 0; mFlinger->mTimeStats->onDestroy(layerId); mFlinger->mFrameTracer->onDestroy(layerId); } // Once we have hit this state, the shadow queue may no longer // correctly reflect the incoming BufferQueue's contents, so even if // updateTexImage starts working, the only safe course of action is // to continue to ignore updates. mUpdateTexImageFailed = true; return BAD_VALUE; } bool more_frames_pending = false; if (queuedBuffer) { // Autolock scope auto currentFrameNumber = mConsumer->getFrameNumber(); Mutex::Autolock lock(mQueueItemLock); // Remove any stale buffers that have been dropped during // updateTexImage while (mQueuedFrames > 0 && mQueueItems[0].item.mFrameNumber != currentFrameNumber) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } uint64_t bufferID = mQueueItems[0].item.mGraphicBuffer->getId(); mFlinger->mTimeStats->setLatchTime(layerId, currentFrameNumber, latchTime); mFlinger->mFrameTracer->traceTimestamp(layerId, bufferID, currentFrameNumber, latchTime, FrameTracer::FrameEvent::LATCH); if (mQueueItems[0].surfaceFrame) { addSurfaceFramePresentedForBuffer(mQueueItems[0].surfaceFrame, mQueueItems[0].item.mFenceTime->getSignalTime(), latchTime); } mQueueItems.erase(mQueueItems.begin()); more_frames_pending = (mQueuedFrames.fetch_sub(1) > 1); } // Decrement the queued-frames count. Signal another event if we // have more frames pending. //减少排队的帧计数。 如果我们有更多待处理的帧，则发出另一个事件的信号。 if ((queuedBuffer && more_frames_pending) || mDrawingState.autoRefresh) { mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 | 知识管理 - PingCode } return NO_ERROR; } BufferLayerConsumer updateTexImage 调用BufferLayerConsumer的updateTexImage方法："><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-06T06:57:52+00:00"><meta property="article:modified_time" content="2024-12-27T14:50:21+00:00"><meta property="article:tag" content="Clippings"><meta property="article:tag" content="转载"><meta property="article:tag" content="Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android13 BufferQueueLayer updateTexImage流程分析-CSDN博客"><meta name=twitter:description content="BufferQueueLayer的updateTexImage方法用于将当前图形缓冲区的内容更新到纹理中，代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp status_t BufferQueueLayer::updateTexImage(bool& recomputeVisibleRegions, nsecs_t latchTime, nsecs_t expectedPresentTime) { // This boolean is used to make sure that SurfaceFlinger's shadow copy // of the buffer queue isn't modified when the buffer queue is returning // BufferItem's that weren't actually queued. This can happen in shared // buffer mode. bool queuedBuffer = false; const int32_t layerId = getSequence(); LayerRejecter r(mDrawingState, getDrawingState(), recomputeVisibleRegions, getProducerStickyTransform() != 0, mName, getTransformToDisplayInverse()); if (isRemovedFromCurrentState()) { expectedPresentTime = 0; } // updateTexImage() below might drop the some buffers at the head of the queue if there is a // buffer behind them which is timely to be presented. However this buffer may not be signaled // yet. The code below makes sure that this wouldn't happen by setting maxFrameNumber to the // last buffer that was signaled. uint64_t lastSignaledFrameNumber = mLastFrameNumberReceived; { Mutex::Autolock lock(mQueueItemLock); for (size_t i = 0; i < mQueueItems.size(); i++) { bool fenceSignaled = mQueueItems[i].item.mFenceTime->getSignalTime() != Fence::SIGNAL_TIME_PENDING; if (!fenceSignaled) { break; } lastSignaledFrameNumber = mQueueItems[i].item.mFrameNumber; } } const uint64_t maxFrameNumberToAcquire = std::min(mLastFrameNumberReceived.load(), lastSignaledFrameNumber); bool autoRefresh; status_t updateResult = mConsumer->updateTexImage(&amp;r, expectedPresentTime, &amp;autoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire); mDrawingState.autoRefresh = autoRefresh; if (updateResult == BufferQueue::PRESENT_LATER) { // Producer doesn't want buffer to be displayed yet. Signal a // layer update so we check again at the next opportunity. // Producer 不希望显示缓冲区。 发出图层更新的信号，以便我们在下次有机会时再次检查。 mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 return BAD_VALUE; } else if (updateResult == BufferLayerConsumer::BUFFER_REJECTED) { // If the buffer has been rejected, remove it from the shadow queue // and return early if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); if (mQueuedFrames > 0) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } } return BAD_VALUE; } else if (updateResult != NO_ERROR || mUpdateTexImageFailed) { // This can occur if something goes wrong when trying to create the // EGLImage for this buffer. If this happens, the buffer has already // been released, so we need to clean up the queue and bug out // early. if (queuedBuffer) { Mutex::Autolock lock(mQueueItemLock); for (auto& [item, surfaceFrame] : mQueueItems) { if (surfaceFrame) { addSurfaceFrameDroppedForBuffer(surfaceFrame); } } mQueueItems.clear(); mQueuedFrames = 0; mFlinger->mTimeStats->onDestroy(layerId); mFlinger->mFrameTracer->onDestroy(layerId); } // Once we have hit this state, the shadow queue may no longer // correctly reflect the incoming BufferQueue's contents, so even if // updateTexImage starts working, the only safe course of action is // to continue to ignore updates. mUpdateTexImageFailed = true; return BAD_VALUE; } bool more_frames_pending = false; if (queuedBuffer) { // Autolock scope auto currentFrameNumber = mConsumer->getFrameNumber(); Mutex::Autolock lock(mQueueItemLock); // Remove any stale buffers that have been dropped during // updateTexImage while (mQueuedFrames > 0 && mQueueItems[0].item.mFrameNumber != currentFrameNumber) { mConsumer->mergeSurfaceDamage(mQueueItems[0].item.mSurfaceDamage); mFlinger->mTimeStats->removeTimeRecord(layerId, mQueueItems[0].item.mFrameNumber); if (mQueueItems[0].surfaceFrame) { addSurfaceFrameDroppedForBuffer(mQueueItems[0].surfaceFrame); } mQueueItems.erase(mQueueItems.begin()); mQueuedFrames--; } uint64_t bufferID = mQueueItems[0].item.mGraphicBuffer->getId(); mFlinger->mTimeStats->setLatchTime(layerId, currentFrameNumber, latchTime); mFlinger->mFrameTracer->traceTimestamp(layerId, bufferID, currentFrameNumber, latchTime, FrameTracer::FrameEvent::LATCH); if (mQueueItems[0].surfaceFrame) { addSurfaceFramePresentedForBuffer(mQueueItems[0].surfaceFrame, mQueueItems[0].item.mFenceTime->getSignalTime(), latchTime); } mQueueItems.erase(mQueueItems.begin()); more_frames_pending = (mQueuedFrames.fetch_sub(1) > 1); } // Decrement the queued-frames count. Signal another event if we // have more frames pending. //减少排队的帧计数。 如果我们有更多待处理的帧，则发出另一个事件的信号。 if ((queuedBuffer && more_frames_pending) || mDrawingState.autoRefresh) { mFlinger->onLayerUpdate(); // (692) SurfaceFlinger onLayerUpdate流程分析 | 知识管理 - PingCode } return NO_ERROR; } BufferLayerConsumer updateTexImage 调用BufferLayerConsumer的updateTexImage方法："><meta name=application-name content="文涛的记录"><meta name=apple-mobile-web-app-title content="文涛的记录"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://huang8604.github.io/posts/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ title="Android13 BufferQueueLayer updateTexImage流程分析-CSDN博客 - 文韬的文档"><link rel=prev type=text/html href=https://huang8604.github.io/posts/android13-bufferqueueproducer-dequeuebuffer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ title="Android13 BufferQueueProducer dequeueBuffer流程分析-CSDN博客"><link rel=next type=text/html href=https://huang8604.github.io/posts/android13-bufferqueuelayer-onlayerdisplayed%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ title="Android13 BufferQueueLayer onLayerDisplayed流程分析-CSDN博客"><link rel=alternate type=text/markdown href=https://huang8604.github.io/posts/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/index.md title="Android13 BufferQueueLayer updateTexImage流程分析-CSDN博客 - 文韬的文档"><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Android13 BufferQueueLayer updateTexImage流程分析-CSDN博客","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/huang8604.github.io\/posts\/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2\/"},"genre":"posts","keywords":"clippings, 转载, blog","wordcount":2903,"url":"https:\/\/huang8604.github.io\/posts\/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2\/","datePublished":"2024-11-06T06:57:52+00:00","dateModified":"2024-12-27T14:50:21+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"wentao"},"description":""}</script><script src=/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=wide><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=文韬的文档><img class=logo src=/images/doc.jpg alt=文韬的文档 height=32 width=32><span class=header-title-text>文韬的文档</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=文韬的文档><img class=logo src=/images/doc.jpg alt=文韬的文档 height=26 width=26><span class=header-title-text>文韬的文档</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Android13 BufferQueueLayer UpdateTexImage流程分析-CSDN博客</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/huang8604 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class=avatar src='https://www.gravatar.com/avatar/b89538cdbc35c279ce1df9f3435f42a1?s=32&d=' alt=wentao height=16 width=16>&nbsp;wentao</a></span><span class=post-included-in>&nbsp;收录于 <a href=/collections/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/ class=post-collection title="合集 - 图形显示"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> 图形显示</a></span></div><div class=post-meta-line><span title="发布于 2024-11-06 06:57:52"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-11-06>2024-11-06</time></span>&nbsp;<span title="更新于 2024-12-27 14:50:21"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-12-27>2024-12-27</time></span>&nbsp;<span title="2903 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 3000 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 6 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#bufferlayerconsumer-updateteximage>BufferLayerConsumer updateTexImage</a><ul><li><a href=#bufferlayerconsumer-acquirebufferlocked>BufferLayerConsumer acquireBufferLocked</a><ul><li><a href=#consumerbase-acquirebufferlocked>ConsumerBase acquireBufferLocked</a><ul><li><a href=#buffqueueconsumer-acquirebuffer>BuffQueueConsumer acquireBuffer</a></li></ul></li></ul></li><li><a href=#bufferlayerconsumer-updateandreleaselocked>BufferLayerConsumer updateAndReleaseLocked</a><ul><li><a href=#consumerbase-releasebufferlocked>ConsumerBase releaseBufferLocked</a><ul><li><a href=#buffqueueconsumer-releasebuffer>BuffQueueConsumer releaseBuffer</a></li></ul></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>BufferQueueLayer的updateTexImage方法用于将当前图形缓冲区的内容更新到纹理中，代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>BufferQueueLayer</span><span class=o>::</span><span class=n>updateTexImage</span><span class=p>(</span><span class=kt>bool</span><span class=o>&amp;</span> <span class=n>recomputeVisibleRegions</span><span class=p>,</span> <span class=n>nsecs_t</span> <span class=n>latchTime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>nsecs_t</span> <span class=n>expectedPresentTime</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This boolean is used to make sure that SurfaceFlinger&#39;s shadow copy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// of the buffer queue isn&#39;t modified when the buffer queue is returning
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// BufferItem&#39;s that weren&#39;t actually queued. This can happen in shared
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// buffer mode.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>queuedBuffer</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int32_t</span> <span class=n>layerId</span> <span class=o>=</span> <span class=n>getSequence</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>LayerRejecter</span> <span class=nf>r</span><span class=p>(</span><span class=n>mDrawingState</span><span class=p>,</span> <span class=n>getDrawingState</span><span class=p>(),</span> <span class=n>recomputeVisibleRegions</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>getProducerStickyTransform</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>mName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>getTransformToDisplayInverse</span><span class=p>());</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isRemovedFromCurrentState</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>expectedPresentTime</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// updateTexImage() below might drop the some buffers at the head of the queue if there is a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// buffer behind them which is timely to be presented. However this buffer may not be signaled
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// yet. The code below makes sure that this wouldn&#39;t happen by setting maxFrameNumber to the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// last buffer that was signaled.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>lastSignaledFrameNumber</span> <span class=o>=</span> <span class=n>mLastFrameNumberReceived</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Mutex</span><span class=o>::</span><span class=n>Autolock</span> <span class=n>lock</span><span class=p>(</span><span class=n>mQueueItemLock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>mQueueItems</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>fenceSignaled</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                    <span class=n>mQueueItems</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mFenceTime</span><span class=o>-&gt;</span><span class=n>getSignalTime</span><span class=p>()</span> <span class=o>!=</span> <span class=n>Fence</span><span class=o>::</span><span class=n>SIGNAL_TIME_PENDING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fenceSignaled</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>lastSignaledFrameNumber</span> <span class=o>=</span> <span class=n>mQueueItems</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mFrameNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>maxFrameNumberToAcquire</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>mLastFrameNumberReceived</span><span class=p>.</span><span class=n>load</span><span class=p>(),</span> <span class=n>lastSignaledFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>autoRefresh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=n>updateResult</span> <span class=o>=</span> <span class=n>mConsumer</span><span class=o>-&gt;</span><span class=n>updateTexImage</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=p>,</span> <span class=n>expectedPresentTime</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>autoRefresh</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=o>&amp;</span><span class=n>queuedBuffer</span><span class=p>,</span> <span class=n>maxFrameNumberToAcquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mDrawingState</span><span class=p>.</span><span class=n>autoRefresh</span> <span class=o>=</span> <span class=n>autoRefresh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>updateResult</span> <span class=o>==</span> <span class=n>BufferQueue</span><span class=o>::</span><span class=n>PRESENT_LATER</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Producer doesn&#39;t want buffer to be displayed yet.  Signal a
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// layer update so we check again at the next opportunity.
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=c1>// Producer 不希望显示缓冲区。 发出图层更新的信号，以便我们在下次有机会时再次检查。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>onLayerUpdate</span><span class=p>();</span> <span class=c1>// (692) SurfaceFlinger onLayerUpdate流程分析 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>BAD_VALUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>updateResult</span> <span class=o>==</span> <span class=n>BufferLayerConsumer</span><span class=o>::</span><span class=n>BUFFER_REJECTED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If the buffer has been rejected, remove it from the shadow queue
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// and return early
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>queuedBuffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Mutex</span><span class=o>::</span><span class=n>Autolock</span> <span class=n>lock</span><span class=p>(</span><span class=n>mQueueItemLock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>mQueuedFrames</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>mConsumer</span><span class=o>-&gt;</span><span class=n>mergeSurfaceDamage</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mSurfaceDamage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>mTimeStats</span><span class=o>-&gt;</span><span class=n>removeTimeRecord</span><span class=p>(</span><span class=n>layerId</span><span class=p>,</span> <span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>surfaceFrame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>addSurfaceFrameDroppedForBuffer</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>surfaceFrame</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>mQueueItems</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>                <span class=n>mQueuedFrames</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>BAD_VALUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>updateResult</span> <span class=o>!=</span> <span class=n>NO_ERROR</span> <span class=o>||</span> <span class=n>mUpdateTexImageFailed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This can occur if something goes wrong when trying to create the
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// EGLImage for this buffer. If this happens, the buffer has already
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// been released, so we need to clean up the queue and bug out
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// early.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>queuedBuffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Mutex</span><span class=o>::</span><span class=n>Autolock</span> <span class=n>lock</span><span class=p>(</span><span class=n>mQueueItemLock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>item</span><span class=p>,</span> <span class=n>surfaceFrame</span><span class=p>]</span> <span class=o>:</span> <span class=n>mQueueItems</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>surfaceFrame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>addSurfaceFrameDroppedForBuffer</span><span class=p>(</span><span class=n>surfaceFrame</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>mQueueItems</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>mQueuedFrames</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>mTimeStats</span><span class=o>-&gt;</span><span class=n>onDestroy</span><span class=p>(</span><span class=n>layerId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>mFrameTracer</span><span class=o>-&gt;</span><span class=n>onDestroy</span><span class=p>(</span><span class=n>layerId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=c1>// Once we have hit this state, the shadow queue may no longer
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// correctly reflect the incoming BufferQueue&#39;s contents, so even if
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// updateTexImage starts working, the only safe course of action is
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// to continue to ignore updates.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mUpdateTexImageFailed</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>BAD_VALUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>more_frames_pending</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>queuedBuffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Autolock scope
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>auto</span> <span class=n>currentFrameNumber</span> <span class=o>=</span> <span class=n>mConsumer</span><span class=o>-&gt;</span><span class=n>getFrameNumber</span><span class=p>();</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>Mutex</span><span class=o>::</span><span class=n>Autolock</span> <span class=n>lock</span><span class=p>(</span><span class=n>mQueueItemLock</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=c1>// Remove any stale buffers that have been dropped during
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// updateTexImage
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>mQueuedFrames</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mFrameNumber</span> <span class=o>!=</span> <span class=n>currentFrameNumber</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mConsumer</span><span class=o>-&gt;</span><span class=n>mergeSurfaceDamage</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mSurfaceDamage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>mTimeStats</span><span class=o>-&gt;</span><span class=n>removeTimeRecord</span><span class=p>(</span><span class=n>layerId</span><span class=p>,</span> <span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>surfaceFrame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>addSurfaceFrameDroppedForBuffer</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>surfaceFrame</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>mQueueItems</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=n>mQueuedFrames</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>bufferID</span> <span class=o>=</span> <span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mGraphicBuffer</span><span class=o>-&gt;</span><span class=n>getId</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>mTimeStats</span><span class=o>-&gt;</span><span class=n>setLatchTime</span><span class=p>(</span><span class=n>layerId</span><span class=p>,</span> <span class=n>currentFrameNumber</span><span class=p>,</span> <span class=n>latchTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>mFrameTracer</span><span class=o>-&gt;</span><span class=n>traceTimestamp</span><span class=p>(</span><span class=n>layerId</span><span class=p>,</span> <span class=n>bufferID</span><span class=p>,</span> <span class=n>currentFrameNumber</span><span class=p>,</span> <span class=n>latchTime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                               <span class=n>FrameTracer</span><span class=o>::</span><span class=n>FrameEvent</span><span class=o>::</span><span class=n>LATCH</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>surfaceFrame</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>addSurfaceFramePresentedForBuffer</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>surfaceFrame</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                              <span class=n>mQueueItems</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>item</span><span class=p>.</span><span class=n>mFenceTime</span><span class=o>-&gt;</span><span class=n>getSignalTime</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                              <span class=n>latchTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>mQueueItems</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>mQueueItems</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>more_frames_pending</span> <span class=o>=</span> <span class=p>(</span><span class=n>mQueuedFrames</span><span class=p>.</span><span class=n>fetch_sub</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// Decrement the queued-frames count.  Signal another event if we
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// have more frames pending.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//减少排队的帧计数。 如果我们有更多待处理的帧，则发出另一个事件的信号。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=n>queuedBuffer</span> <span class=o>&amp;&amp;</span> <span class=n>more_frames_pending</span><span class=p>)</span> <span class=o>||</span> <span class=n>mDrawingState</span><span class=p>.</span><span class=n>autoRefresh</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mFlinger</span><span class=o>-&gt;</span><span class=n>onLayerUpdate</span><span class=p>();</span> <span class=c1>// (692) SurfaceFlinger onLayerUpdate流程分析 | 知识管理 - PingCode 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 class=heading-element id=bufferlayerconsumer-updateteximage><span>BufferLayerConsumer updateTexImage</span>
<a href=#bufferlayerconsumer-updateteximage class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>调用BufferLayerConsumer的updateTexImage方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/surfaces/surfaceflienger/BufferLayerConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>BufferLayerConsumer</span><span class=o>::</span><span class=n>updateTexImage</span><span class=p>(</span><span class=n>BufferRejecter</span><span class=o>*</span> <span class=n>rejecter</span><span class=p>,</span> <span class=n>nsecs_t</span> <span class=n>expectedPresentTime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=kt>bool</span><span class=o>*</span> <span class=n>autoRefresh</span><span class=p>,</span> <span class=kt>bool</span><span class=o>*</span> <span class=n>queuedBuffer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=kt>uint64_t</span> <span class=n>maxFrameNumber</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ATRACE_CALL</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>BLC_LOGV</span><span class=p>(</span><span class=s>&#34;updateTexImage&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex</span><span class=o>::</span><span class=n>Autolock</span> <span class=n>lock</span><span class=p>(</span><span class=n>mMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mAbandoned</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BLC_LOGE</span><span class=p>(</span><span class=s>&#34;updateTexImage: BufferLayerConsumer is abandoned!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>NO_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>BufferItem</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// Acquire the next buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// In asynchronous mode the list is guaranteed to be one buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// deep, while in synchronous mode we use the oldest buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>acquireBufferLocked</span><span class=p>(</span><span class=o>&amp;</span><span class=n>item</span><span class=p>,</span> <span class=n>expectedPresentTime</span><span class=p>,</span> <span class=n>maxFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>BufferQueue</span><span class=o>::</span><span class=n>NO_BUFFER_AVAILABLE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>err</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>BufferQueue</span><span class=o>::</span><span class=n>PRESENT_LATER</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// return the error, without logging
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>BLC_LOGE</span><span class=p>(</span><span class=s>&#34;updateTexImage: acquire failed: %s (%d)&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=o>-</span><span class=n>err</span><span class=p>),</span> <span class=n>err</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>autoRefresh</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>autoRefresh</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mAutoRefresh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>queuedBuffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>queuedBuffer</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mQueuedBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// We call the rejecter here, in case the caller has a reason to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// not accept this buffer.  This is used by SurfaceFlinger to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// reject buffers which have the wrong size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//我们在这里调用拒绝器，以防调用者有理由不接受此缓冲区， SurfaceFlinger 使用它来拒绝大小错误的缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>slot</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mSlot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rejecter</span> <span class=o>&amp;&amp;</span> <span class=n>rejecter</span><span class=o>-&gt;</span><span class=n>reject</span><span class=p>(</span><span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mGraphicBuffer</span><span class=p>,</span> <span class=n>item</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>releaseBufferLocked</span><span class=p>(</span><span class=n>slot</span><span class=p>,</span> <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mGraphicBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>BUFFER_REJECTED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// Release the previous buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>err</span> <span class=o>=</span> <span class=n>updateAndReleaseLocked</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mPendingRelease</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>上面方法的主要处理如下：</p><p>1、调用BufferLayerConsumer的acquireBufferLocked方法，从BufferQueue中获取一个可用的图像缓冲区。</p><p>2、调用BufferLayerConsumer的updateAndReleaseLocked方法，释放图像缓冲区。</p><p>下面分别进行分析：</p><h3 class=heading-element id=bufferlayerconsumer-acquirebufferlocked><span>BufferLayerConsumer acquireBufferLocked</span>
<a href=#bufferlayerconsumer-acquirebufferlocked class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>调用BufferLayerConsumer的acquireBufferLocked方法，从BufferQueue中获取一个可用的图像缓冲区：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>BufferLayerConsumer</span><span class=o>::</span><span class=n>acquireBufferLocked</span><span class=p>(</span><span class=n>BufferItem</span><span class=o>*</span> <span class=n>item</span><span class=p>,</span> <span class=n>nsecs_t</span> <span class=n>presentWhen</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                  <span class=kt>uint64_t</span> <span class=n>maxFrameNumber</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>ConsumerBase</span><span class=o>::</span><span class=n>acquireBufferLocked</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>presentWhen</span><span class=p>,</span> <span class=n>maxFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// If item-&gt;mGraphicBuffer is not null, this buffer has not been acquired
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// before, so we need to clean up old references.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mGraphicBuffer</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mImagesMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mImages</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>]</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>||</span> <span class=n>mImages</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>getBuffer</span><span class=p>()</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=n>mImages</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>getBuffer</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getId</span><span class=p>()</span> <span class=o>!=</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>mGraphicBuffer</span><span class=o>-&gt;</span><span class=n>getId</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mImages</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>                    <span class=n>renderengine</span><span class=o>::</span><span class=n>impl</span><span class=o>::</span><span class=n>ExternalTexture</span><span class=o>&gt;</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mGraphicBuffer</span><span class=p>,</span> <span class=n>mRE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                         <span class=n>renderengine</span><span class=o>::</span><span class=n>impl</span><span class=o>::</span><span class=n>ExternalTexture</span><span class=o>::</span>
</span></span><span class=line><span class=cl>                                                                 <span class=n>Usage</span><span class=o>::</span><span class=n>READABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 class=heading-element id=consumerbase-acquirebufferlocked><span>ConsumerBase acquireBufferLocked</span>
<a href=#consumerbase-acquirebufferlocked class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>BufferLayerConsumer继承于ConsumerBase，调用ConsumerBase的acquireBufferLocked方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/libs/gui/ConsumerBase.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sp</span><span class=o>&lt;</span><span class=n>IGraphicBufferConsumer</span><span class=o>&gt;</span> <span class=n>mConsumer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>status_t</span> <span class=n>ConsumerBase</span><span class=o>::</span><span class=n>acquireBufferLocked</span><span class=p>(</span><span class=n>BufferItem</span> <span class=o>*</span><span class=n>item</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>nsecs_t</span> <span class=n>presentWhen</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>maxFrameNumber</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mAbandoned</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CB_LOGE</span><span class=p>(</span><span class=s>&#34;acquireBufferLocked: ConsumerBase is abandoned!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>NO_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>mConsumer</span><span class=o>-&gt;</span><span class=n>acquireBuffer</span><span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>presentWhen</span><span class=p>,</span> <span class=n>maxFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mGraphicBuffer</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mSlots</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>].</span><span class=n>mGraphicBuffer</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>freeBufferLocked</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>mSlots</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>].</span><span class=n>mGraphicBuffer</span> <span class=o>=</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>mGraphicBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>mSlots</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>].</span><span class=n>mFrameNumber</span> <span class=o>=</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>mFrameNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mSlots</span><span class=p>[</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>].</span><span class=n>mFence</span> <span class=o>=</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>mFence</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>CB_LOGV</span><span class=p>(</span><span class=s>&#34;acquireBufferLocked: -&gt; slot=%d/%&#34;</span> <span class=n>PRIu64</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>item</span><span class=o>-&gt;</span><span class=n>mSlot</span><span class=p>,</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>mFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>调用mConsumer(IGraphicBufferConsumer)的acquireBuffer方法，IGraphicBufferConsumer是一个接口，由BpGraphicBufferConsumer实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/libs/gui/IGraphicBufferConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>BpGraphicBufferConsumer</span> <span class=o>:</span> <span class=k>public</span> <span class=n>SafeBpInterface</span><span class=o>&lt;</span><span class=n>IGraphicBufferConsumer</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=nf>acquireBuffer</span><span class=p>(</span><span class=n>BufferItem</span><span class=o>*</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>nsecs_t</span> <span class=n>presentWhen</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=kt>uint64_t</span> <span class=n>maxFrameNumber</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>Signature</span> <span class=o>=</span> <span class=k>decltype</span><span class=p>(</span><span class=o>&amp;</span><span class=n>IGraphicBufferConsumer</span><span class=o>::</span><span class=n>acquireBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>callRemote</span><span class=o>&lt;</span><span class=n>Signature</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Tag</span><span class=o>::</span><span class=n>ACQUIRE_BUFFER</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>presentWhen</span><span class=p>,</span> <span class=n>maxFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>调用callRemote方法进行远程调用，之后会运行BnGraphicBufferConsumer的onTransact方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/libs/gui/IGraphicBufferConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>BnGraphicBufferConsumer</span><span class=o>::</span><span class=n>onTransact</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>code</span><span class=p>,</span> <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span> <span class=n>Parcel</span><span class=o>*</span> <span class=n>reply</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>code</span> <span class=o>&lt;</span> <span class=n>IBinder</span><span class=o>::</span><span class=n>FIRST_CALL_TRANSACTION</span> <span class=o>||</span> <span class=n>code</span> <span class=o>&gt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Tag</span><span class=o>::</span><span class=n>LAST</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>BBinder</span><span class=o>::</span><span class=n>onTransact</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>tag</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Tag</span><span class=o>&gt;</span><span class=p>(</span><span class=n>code</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>tag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>Tag</span><span class=o>::</span><span class=nl>ACQUIRE_BUFFER</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>callLocal</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>IGraphicBufferConsumer</span><span class=o>::</span><span class=n>acquireBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 class=heading-element id=buffqueueconsumer-acquirebuffer><span>BuffQueueConsumer acquireBuffer</span>
<a href=#buffqueueconsumer-acquirebuffer class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>BuffQueueConsumer继承于BnGraphicBufferConsumer，调用BnGraphicBufferConsumer的acquireBuffer方法：</p><p><a href=/Android13%20BufferQueueConsumer%20acquireBuffer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-CSDN%E5%8D%9A%E5%AE%A2>Android13 BufferQueueConsumer acquireBuffer流程分析-CSDN博客</a></p><h3 class=heading-element id=bufferlayerconsumer-updateandreleaselocked><span>BufferLayerConsumer updateAndReleaseLocked</span>
<a href=#bufferlayerconsumer-updateandreleaselocked class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>调用BufferLayerConsumer的updateAndReleaseLocked方法，释放图像缓冲区：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>BufferLayerConsumer</span><span class=o>::</span><span class=n>updateAndReleaseLocked</span><span class=p>(</span><span class=k>const</span> <span class=n>BufferItem</span><span class=o>&amp;</span> <span class=n>item</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                     <span class=n>PendingRelease</span><span class=o>*</span> <span class=n>pendingRelease</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>slot</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mSlot</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>BLC_LOGV</span><span class=p>(</span><span class=s>&#34;updateAndRelease: (slot=%d buf=%p) -&gt; (slot=%d buf=%p)&#34;</span><span class=p>,</span> <span class=n>mCurrentTexture</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=p>(</span><span class=n>mCurrentTextureBuffer</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>mCurrentTextureBuffer</span><span class=o>-&gt;</span><span class=n>getBuffer</span><span class=p>()</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                     <span class=o>?</span> <span class=n>mCurrentTextureBuffer</span><span class=o>-&gt;</span><span class=n>getBuffer</span><span class=p>()</span><span class=o>-&gt;</span><span class=nl>handle</span>
</span></span><span class=line><span class=cl>                     <span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>slot</span><span class=p>,</span> <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mGraphicBuffer</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// Hang onto the pointer so that it isn&#39;t freed in the call to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// releaseBufferLocked() if we&#39;re in shared buffer mode and both buffers are
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the same.
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>renderengine</span><span class=o>::</span><span class=n>ExternalTexture</span><span class=o>&gt;</span> <span class=n>nextTextureBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mImagesMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>nextTextureBuffer</span> <span class=o>=</span> <span class=n>mImages</span><span class=p>[</span><span class=n>slot</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// release old buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>mCurrentTexture</span> <span class=o>!=</span> <span class=n>BufferQueue</span><span class=o>::</span><span class=n>INVALID_BUFFER_SLOT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pendingRelease</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>status_t</span> <span class=n>status</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                    <span class=n>releaseBufferLocked</span><span class=p>(</span><span class=n>mCurrentTexture</span><span class=p>,</span> <span class=n>mCurrentTextureBuffer</span><span class=o>-&gt;</span><span class=n>getBuffer</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>BLC_LOGE</span><span class=p>(</span><span class=s>&#34;updateAndRelease: failed to release buffer: %s (%d)&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=o>-</span><span class=n>status</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                         <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>err</span> <span class=o>=</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=c1>// keep going, with error raised [?]
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pendingRelease</span><span class=o>-&gt;</span><span class=n>currentTexture</span> <span class=o>=</span> <span class=n>mCurrentTexture</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>pendingRelease</span><span class=o>-&gt;</span><span class=n>graphicBuffer</span> <span class=o>=</span> <span class=n>mCurrentTextureBuffer</span><span class=o>-&gt;</span><span class=n>getBuffer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>pendingRelease</span><span class=o>-&gt;</span><span class=n>isPending</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// Update the BufferLayerConsumer state.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mCurrentTexture</span> <span class=o>=</span> <span class=n>slot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentTextureBuffer</span> <span class=o>=</span> <span class=n>nextTextureBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentCrop</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mCrop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentTransform</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mTransform</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentScalingMode</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mScalingMode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentTimestamp</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mTimestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentDataSpace</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>ui</span><span class=o>::</span><span class=n>Dataspace</span><span class=o>&gt;</span><span class=p>(</span><span class=n>item</span><span class=p>.</span><span class=n>mDataSpace</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentHdrMetadata</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mHdrMetadata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentFence</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mFence</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentFenceTime</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mFenceTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentFrameNumber</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mFrameNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentTransformToDisplayInverse</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mTransformToDisplayInverse</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentSurfaceDamage</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mSurfaceDamage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mCurrentApi</span> <span class=o>=</span> <span class=n>item</span><span class=p>.</span><span class=n>mApi</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>computeCurrentTransformMatrixLocked</span><span class=p>();</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 class=heading-element id=consumerbase-releasebufferlocked><span>ConsumerBase releaseBufferLocked</span>
<a href=#consumerbase-releasebufferlocked class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>BufferLayerConsumer继承于ConsumerBase，调用ConsumerBase的releaseBufferLocked方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/libs/gui/ConsumerBase.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>ConsumerBase</span><span class=o>::</span><span class=n>releaseBufferLocked</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>slot</span><span class=p>,</span> <span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>GraphicBuffer</span><span class=o>&gt;</span> <span class=n>graphicBuffer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>EGLDisplay</span> <span class=n>display</span><span class=p>,</span> <span class=n>EGLSyncKHR</span> <span class=n>eglFence</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mAbandoned</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CB_LOGE</span><span class=p>(</span><span class=s>&#34;releaseBufferLocked: ConsumerBase is abandoned!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>NO_INIT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If consumer no longer tracks this graphicBuffer (we received a new
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// buffer on the same slot), the buffer producer is definitely no longer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// tracking it.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>stillTracking</span><span class=p>(</span><span class=n>slot</span><span class=p>,</span> <span class=n>graphicBuffer</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>CB_LOGV</span><span class=p>(</span><span class=s>&#34;releaseBufferLocked: slot=%d/%&#34;</span> <span class=n>PRIu64</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>slot</span><span class=p>,</span> <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mFrameNumber</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>mConsumer</span><span class=o>-&gt;</span><span class=n>releaseBuffer</span><span class=p>(</span><span class=n>slot</span><span class=p>,</span> <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mFrameNumber</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>display</span><span class=p>,</span> <span class=n>eglFence</span><span class=p>,</span> <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mFence</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>IGraphicBufferConsumer</span><span class=o>::</span><span class=n>STALE_BUFFER_SLOT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>freeBufferLocked</span><span class=p>(</span><span class=n>slot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>mPrevFinalReleaseFence</span> <span class=o>=</span> <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mFence</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mSlots</span><span class=p>[</span><span class=n>slot</span><span class=p>].</span><span class=n>mFence</span> <span class=o>=</span> <span class=n>Fence</span><span class=o>::</span><span class=n>NO_FENCE</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>调用mConsumer(IGraphicBufferConsumer)的releaseBuffer</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/include/gui/IGraphicBufferConsumer.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>ReleaseBuffer</span> <span class=o>=</span> <span class=k>decltype</span><span class=p>(</span><span class=o>&amp;</span><span class=n>IGraphicBufferConsumer</span><span class=o>::</span><span class=n>releaseHelper</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//frameworks/native/libs/gui/IGraphicBufferConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>status_t</span> <span class=n>BnGraphicBufferConsumer</span><span class=o>::</span><span class=n>onTransact</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>code</span><span class=p>,</span> <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span> <span class=n>Parcel</span><span class=o>*</span> <span class=n>reply</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>code</span> <span class=o>&lt;</span> <span class=n>IBinder</span><span class=o>::</span><span class=n>FIRST_CALL_TRANSACTION</span> <span class=o>||</span> <span class=n>code</span> <span class=o>&gt;</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Tag</span><span class=o>::</span><span class=n>LAST</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>BBinder</span><span class=o>::</span><span class=n>onTransact</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>tag</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>Tag</span><span class=o>&gt;</span><span class=p>(</span><span class=n>code</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>tag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>Tag</span><span class=o>::</span><span class=nl>RELEASE_BUFFER</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>callLocal</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>IGraphicBufferConsumer</span><span class=o>::</span><span class=n>releaseHelper</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>seBuffer方法，IGraphicBufferConsumer是一个接口，由BpGraphicBufferConsumer实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//frameworks/native/libs/gui/IGraphicBufferConsumer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>BpGraphicBufferConsumer</span> <span class=o>:</span> <span class=k>public</span> <span class=n>SafeBpInterface</span><span class=o>&lt;</span><span class=n>IGraphicBufferConsumer</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>status_t</span> <span class=nf>releaseBuffer</span><span class=p>(</span><span class=kt>int</span> <span class=n>buf</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>frameNumber</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>EGLDisplay</span> <span class=n>display</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>unused</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>                           <span class=n>EGLSyncKHR</span> <span class=n>fence</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>unused</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>                           <span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>Fence</span><span class=o>&gt;&amp;</span> <span class=n>releaseFence</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>callRemote</span><span class=o>&lt;</span><span class=n>ReleaseBuffer</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Tag</span><span class=o>::</span><span class=n>RELEASE_BUFFER</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>frameNumber</span><span class=p>,</span> <span class=n>releaseFence</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>调用callRemote方法进行远程调用，之后会运行BnGraphicBufferConsumer的onTransact方法：</p><h5 class=heading-element id=buffqueueconsumer-releasebuffer><span>BuffQueueConsumer releaseBuffer</span>
<a href=#buffqueueconsumer-releasebuffer class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>BuffQueueConsumer继承于BnGraphicBufferConsumer，调用BnGraphicBufferConsumer的ReleaseBuffer 方法：</p><p><a href=/Android13%20BufferQueueConsumer%20releaseBuffer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-CSDN%E5%8D%9A%E5%AE%A2>Android13 BufferQueueConsumer releaseBuffer流程分析-CSDN博客</a></p></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・图形显示</span></span></a> 43</div><div class=collection-nav><a href=/posts/android13-bufferqueuelayer-onlayerdisplayed%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ class=collection-nav-item rel=prev title="Android13 BufferQueueLayer OnLayerDisplayed流程分析-CSDN博客"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>Android13 BufferQueueLayer OnLayerDisplayed流程分析-CSDN博客</span>
</a><a href=/posts/android13-bufferqueueproducer-dequeuebuffer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ class=collection-nav-item rel=next title="Android13 BufferQueueProducer DequeueBuffer流程分析-CSDN博客"><span>Android13 BufferQueueProducer DequeueBuffer流程分析-CSDN博客</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-12-27 14:50:21">更新于 2024-12-27&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://huang8604.github.io/posts/android13-bufferqueuelayer-updateteximage%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ data-title="Android13 BufferQueueLayer UpdateTexImage流程分析-CSDN博客"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/clippings/ class=post-tag title="标签 - Clippings">Clippings</a><a href=/tags/%E8%BD%AC%E8%BD%BD/ class=post-tag title="标签 - 转载">转载</a><a href=/tags/blog/ class=post-tag title="标签 - Blog">Blog</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/android13-bufferqueueproducer-dequeuebuffer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ class=post-nav-item rel=prev title="Android13 BufferQueueProducer DequeueBuffer流程分析-CSDN博客"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Android13 BufferQueueProducer DequeueBuffer流程分析-CSDN博客</a><a href=/posts/android13-bufferqueuelayer-onlayerdisplayed%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-csdn%E5%8D%9A%E5%AE%A2/ class=post-nav-item rel=next title="Android13 BufferQueueLayer OnLayerDisplayed流程分析-CSDN博客">Android13 BufferQueueLayer OnLayerDisplayed流程分析-CSDN博客<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=static></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=huang8604/huang8604.github.io data-repo-id=R_kgDOMx3bEg data-category=Announcements data-category-id=DIC_kwDOMx3bEs4CigIp data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.152.2"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.20"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/huang8604 target=_blank rel="external nofollow noopener noreferrer">wentao</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:199},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.20"}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>