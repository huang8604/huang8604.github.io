<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客 - 文韬的文档</title><meta name=author content="wentao"><meta name=description content="从Android 12开始，Android的绘制系统有结构性变化， 在绘制的生产消费者模式中，新增BLASTBufferQueue，客户端进程自行进行queue的生产和消费，随后通过Transation提交到SurfaceFlinger，如此可以使得各进程将缓存提交到SufrfaceFlinger后合并到同一事务后同步提交，在同一帧生效。实际上，从Android12到Android14整个绘制系统在各个环节也都有了或大或小的调整，比如Android13发布了1.3版本的Vulkan, Android14新增了TextureView，等等。本文基于Android14。1
"><meta name=keywords content='clippings,转载,blog'><meta itemprop=name content="Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客"><meta itemprop=description content="从Android 12开始，Android的绘制系统有结构性变化， 在绘制的生产消费者模式中，新增BLASTBufferQueue，客户端进程自行进行queue的生产和消费，随后通过Transation提交到SurfaceFlinger，如此可以使得各进程将缓存提交到SufrfaceFlinger后合并到同一事务后同步提交，在同一帧生效。实际上，从Android12到Android14整个绘制系统在各个环节也都有了或大或小的调整，比如Android13发布了1.3版本的Vulkan, Android14新增了TextureView，等等。本文基于Android14。1"><meta itemprop=datePublished content="2024-11-06T06:57:53+00:00"><meta itemprop=dateModified content="2024-11-05T01:33:59+00:00"><meta itemprop=wordCount content="7872"><meta itemprop=keywords content="Clippings,转载,Blog"><meta property="og:url" content="https://huang8604.github.io/posts/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2/"><meta property="og:site_name" content="文韬的文档"><meta property="og:title" content="Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客"><meta property="og:description" content="从Android 12开始，Android的绘制系统有结构性变化， 在绘制的生产消费者模式中，新增BLASTBufferQueue，客户端进程自行进行queue的生产和消费，随后通过Transation提交到SurfaceFlinger，如此可以使得各进程将缓存提交到SufrfaceFlinger后合并到同一事务后同步提交，在同一帧生效。实际上，从Android12到Android14整个绘制系统在各个环节也都有了或大或小的调整，比如Android13发布了1.3版本的Vulkan, Android14新增了TextureView，等等。本文基于Android14。1"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-06T06:57:53+00:00"><meta property="article:modified_time" content="2024-11-05T01:33:59+00:00"><meta property="article:tag" content="Clippings"><meta property="article:tag" content="转载"><meta property="article:tag" content="Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客"><meta name=twitter:description content="从Android 12开始，Android的绘制系统有结构性变化， 在绘制的生产消费者模式中，新增BLASTBufferQueue，客户端进程自行进行queue的生产和消费，随后通过Transation提交到SurfaceFlinger，如此可以使得各进程将缓存提交到SufrfaceFlinger后合并到同一事务后同步提交，在同一帧生效。实际上，从Android12到Android14整个绘制系统在各个环节也都有了或大或小的调整，比如Android13发布了1.3版本的Vulkan, Android14新增了TextureView，等等。本文基于Android14。1"><meta name=application-name content="文涛的记录"><meta name=apple-mobile-web-app-title content="文涛的记录"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://huang8604.github.io/posts/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2/ title="Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客 - 文韬的文档"><link rel=prev type=text/html href=https://huang8604.github.io/posts/android-surfaceflinger-csdn%E5%8D%9A%E5%AE%A2/ title="Android SurfaceFlinger-CSDN博客"><link rel=next type=text/html href=https://huang8604.github.io/posts/%E6%B1%87%E6%80%BBbinder%E7%9B%B8%E5%85%B3%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/ title=汇总binder相关一些常见面试题-安卓系统常见面试题-CSDN博客><link rel=alternate type=text/markdown href=https://huang8604.github.io/posts/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2/index.md title="Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客 - 文韬的文档"><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/huang8604.github.io\/posts\/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2\/"},"genre":"posts","keywords":"clippings, 转载, blog","wordcount":7872,"url":"https:\/\/huang8604.github.io\/posts\/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2\/","datePublished":"2024-11-06T06:57:53+00:00","dateModified":"2024-11-05T01:33:59+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"wentao"},"description":""}</script><script src=/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=wide><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=文韬的文档><img class=logo src=/images/doc.jpg alt=文韬的文档 height=32 width=32><span class=header-title-text>文韬的文档</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=文韬的文档><img class=logo src=/images/doc.jpg alt=文韬的文档 height=26 width=26><span class=header-title-text>文韬的文档</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 归档</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/huang8604 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class=avatar src='https://www.gravatar.com/avatar/b89538cdbc35c279ce1df9f3435f42a1?s=32&d=' alt=wentao height=16 width=16>&nbsp;wentao</a></span><span class=post-included-in>&nbsp;收录于 <a href=/collections/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/ class=post-collection title="合集 - 图形显示"><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> 图形显示</a></span></div><div class=post-meta-line><span title="发布于 2024-11-06 06:57:53"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-11-06>2024-11-06</time></span>&nbsp;<span title="更新于 2024-11-05 01:33:59"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-11-05>2024-11-05</time></span>&nbsp;<span title="7872 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 7900 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 16 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#android绘制系统整体架构><strong>Android 绘制系统整体架构：</strong></a></li><li><a href=#1-客户端绘制和渲染><strong>1. 客户端绘制和渲染</strong></a><ul><li><ul><li><a href=#opengles-vsvulkan><strong>OpenGL</strong> <strong>E****S</strong> <strong>VS</strong> <strong>Vulkan</strong></a></li></ul></li></ul></li><li><a href=#2-hw-composerhwc2图像合成><strong>2. HW</strong> <strong>Composer</strong>**（HWC2）**<strong>图像合成</strong></a></li><li><a href=#4-vsync><strong>4. V****SYNC</strong></a><ul><li><ul><li><a href=#vsync简介><strong>VSync简介：</strong></a></li><li><a href=#android的vsync><strong>Android的V****SYNC</strong></a></li><li><a href=#可变刷新率><strong>可变刷新率</strong></a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>从Android 12开始，Android的绘制系统有结构性变化， 在绘制的生产消费者模式中，新增BLASTBufferQueue，客户端进程自行进行queue的生产和消费，随后通过Transation提交到SurfaceFlinger，如此可以使得各进程将缓存提交到SufrfaceFlinger后合并到同一事务后同步提交，在同一帧生效。实际上，从Android12到Android14整个绘制系统在各个环节也都有了或大或小的调整，比如Android13发布了1.3版本的Vulkan, Android14新增了TextureView，等等。本文基于Android14。1</p><h2 class=heading-element id=android绘制系统整体架构><span><strong>Android 绘制系统整体架构：</strong></span>
<a href=#android%e7%bb%98%e5%88%b6%e7%b3%bb%e7%bb%9f%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6c6d970.png title=cf0cdc25ecef8aafa7ec629537646867\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6c6d970.png data-sub-html="<h2>cf0cdc25ecef8aafa7ec629537646867\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6c6d970.png alt=cf0cdc25ecef8aafa7ec629537646867\_MD5></a></p><p>从上到下可以理解为“生产者（Producer）”到“消费者（Consumer）”的处理过程。</p><p>首先，从WindowManagerService的角度，每个窗口称为Window，一个Window一般是一个APP的页面，或者Status Bar，或者Navigation Bar，或者WallPaper，这些都是一个个Window。WindowManagerService（WMS）作为服务端，对所有客户端窗口的添加、层级、布局等进行统一管理。在WMS端，每个Window对应一个Surface。Surface可以理解为图像数据缓存的持有者，以及Canvas的持有者。Canvas是画布，提供了绘制各种图形的能力供开发者使用。一个客户端窗口在建立之初，会先向WMS去申请一个Surface，WMS在创建了Surface之后，通过binder返回给客户端。客户端拿到Surface后，会去创建一个BLASTBufferQueue来管理图像内存的申请。每次要使用Surface的Canvas进行绘制前，需要先向BLASTBufferQueue申请一块内存（dequeue），我们这里称为Buffer，然后再将生成的图像数据写入Buffer。这个向BLASTBufferQueue申请Buffer并写入图像数据的过程，可以认为是“生产”阶段。随后，enqueue这个buffer，将其提交给SurfaceFlinger去合成。这个阶段，可以理解为图像Buffer的“消费”阶段。</p><p>SurfaceFlinger（SF）是负责与Hardware层沟通，维护着设备挂载、VSync信号收发、Layer合成等工作。WMS的每个Surface在SurfaceFlinger中都对应生成一个Layer对象。客户端将某个Surface上的Buffer提交给SurfaceFlinger，实际上就是更新了对应Layer的Buffer数据。SurfaceFlinger调用HWComposer将这些Layer进行合成并显示在屏幕。</p><p>Android在HAL层提供称为一个Hardware Composer的组件，用于隔离与具体硬件的交互。Hardware Composer简称HWComposer或HWC2（之所以是2，是早期已有一个HWC版本，只支持软件合成）。SurfaceFlinger把Layer数据交给HWComposer，各厂商来负责HWComposer合成接口的具体实现。在合成完毕后，将数据提交到屏幕设备的缓存（一般称为Frame Buffer），屏幕就显示出画面来了。</p><p>上面的过程，可以拆解为几部分：</p><ol><li>Surface的创建与管理。</li><li>客户端（EndPoint）绘制（Draw）和渲染（Render）图像。</li><li>第三部分，是硬件Composition（合成）工作</li><li>Vsync：由硬件产生的信号，用于同步framebuffer的生产和消费。SurfaceFlinger对Vsync进行了使用和管理，并向上分发给APP。Vsync是不断绘制的驱动力，也是图像缓存有序投送到屏幕的重要机制。</li></ol><p>现在，分别讨论下四部分：</p><ol><li><strong>Surface的<strong><strong>创建</strong></strong>与管理</strong></li></ol><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff664a402.png title=41a9699ee80b12c7024b0eb587446d57\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff664a402.png data-sub-html="<h2>41a9699ee80b12c7024b0eb587446d57\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff664a402.png alt=41a9699ee80b12c7024b0eb587446d57\_MD5></a></p><p>在Surface的创建过程中，有几个角色贯穿其中：</p><p>PhoneWindow：一个Activity对应一个PhoneWindow，代表一个应用窗口。在AMS创建Activity之初，PhoneWindow在服务端的对应的window对象（ActivityRecord）已经添加到WMS。</p><p>ViewRootImpl：其主要作用是与服务端通信，承接外部触发的绘制调用，从而从上往下对整个View树进行绘制。可以把ViewRootImp理解为View的调度者。ViewRootImp在逻辑上是View Hierarchy的最顶层，但其并不是一个真正的View。他持有一个字View&ndash;DecorView，DecorView才是真正的View，是View树的最上层，包含着Activity的画面内容。在Activity的resume阶段，ViewRootImpl的relayout方法会将DecorView添加到WMS中，这样Activity的内容就显示了出来。逻辑上，我们可以把DecorView也理解为一个Window。Activity对应一个PhoneWindow，再通过ViewRootImpl将DecorView在WMS端添加为PhoneWindow的子Window。</p><p>WMS的Session：客户端一个进程对应WMS里的一个Session，客户端持有Session的binder客户端，在窗口添加等事务上，客户端都是通过这个Session来与WMS通信的。</p><p>WindowContainer：WMS端管理系统整体的Window体系，包括其位置、层级关系。它是通过WindowContainer这个类来表达一个Window的。DisplayContent代表一个屏幕级别的Window，DisplayArea代表一块屏幕上的一块区域，比如平板等大屏幕设备上，可能一块屏幕上同时显示多个应用区域，此时就用DisplayArea表达。WindowToken简单理解为对应一个客户端Window，比如一个应用的Activity，这里需要注意的是，Activity的WindowToken是作为ActivityRecord存在的，也就是说ActivityRecord是WindowToken的子类。而Activity的具体内容的承载者，DecorView，对应WindowState。上面所有的DisplayContent、DisplayArea、WindowToken、WindowState等，都是WindowContainer的子类，这些Window在WMS内是以window树的形式组织起来的。事实上，在DisplayContent下面，还有一个层级，称为Feature，具体的层级结构见<a href=https://blog.csdn.net/temp7695/article/details/136630565 title="Android12 - WMS之WindowContainer树（DisplayArea）_android windowcontainer-CSDN博客" target=_blank rel="external nofollow noopener noreferrer">Android12 - WMS之WindowContainer树（DisplayArea）_android windowcontainer-CSDN博客</a>。当客户端通过Session接口调用添加DecorView时，WMS端会生成一个对应的WindowState对象，并将其作为Activity对应的ActivityRecord（也就是WindowToken）的子window。</p><p>SurfaceControl：在WMS端，每个WindowContainer对应一个SurfaceControl。SurfaceControl是WMS端管理Surface的具体对象，在WMS端，可以理解一个SurfaceControl就代表一个Surface。SurfaceControl在SurfaceFlinge端对应一个Layer，持有一个layer的句柄handle。所有的绘制动作，最后都会提交到SurfaceFinger作为Layer去合成。SurfaceControl的作用，或者Surface的作用，主要是将客户端的窗口与SurfaceFlinger的Layer关联起来。在客户端Add一个DecorView时， 在WMS端对应创建的WindowState会同时创建一个SurfaceControl、Layer，随后将SurfaceControl返回给客户端。客户端拿到SurfaceControl之后转换成Surface。后续的绘制就在这个Surface上进行。</p><p>SurfaceComposerClient：是一个Binder，主要作用是SurfaceControl调用SurfaceFlinger过程中，作为一个通道的角色。由于SurfaceControl在WMS、客户端都持有，所以客户端、WMS都可以通过这个通道调用SF。比如Layer的创建、Graphihc Buffer的提交等。</p><h2 class=heading-element id=1-客户端绘制和渲染><span><strong>1. 客户端绘制和渲染</strong></span>
<a href=#1-%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bb%98%e5%88%b6%e5%92%8c%e6%b8%b2%e6%9f%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>客户端通过Surface中提供的Canvas进行绘制，Canvas是基于Skia的SKCanvas。Skia（<a href=https://skia.org/ title=https://skia.org/ target=_blank rel="external nofollow noopener noreferrer">https://skia.org/</a>）是由Google管理的开源2D（也可以支持3D）图像库，目前Android、Google Chrome、ChromeOS、Mozilla FireFox、FireFoxOS上都使用Skia作为绘制引擎。Skia可以集成OPEN GL和Vulkan进行3D绘制。Android Q以后，Skia作用被加强，即使硬件加速场景中，绘制也会先封装成Skia的GrOpList再提交给GPU。在Android 14中， Skia包的目录为external/skia。</p><p>渲染的过程是将画好的图像，进行栅格化（Rasterizer），变成一个个像素，这是一个非常耗时的过程。Android 3以前，只支持软件渲染，即Software Render。过程如下：<a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff66a7384.png title=68e16cc08a8c89424329ac7c071be04c\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff66a7384.png data-sub-html="<h2>68e16cc08a8c89424329ac7c071be04c\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff66a7384.png alt=68e16cc08a8c89424329ac7c071be04c\_MD5></a></p><p>APP在View的onDraw阶段使用Canvas绘制后，通过Skia进行软件的栅格化，即通过CPU计算，将绘制内容转化成一个个像素信息，随后投送给屏幕进行显示。由于软件渲染效率低，当下软件渲染只是作为兼容方案得以保留，默认使用硬件加速。</p><p>硬件加速的流程简单表述如下：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6682e64.png title=1949a8de23b1f248e4cbe33b7f0564d1\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6682e64.png data-sub-html="<h2>1949a8de23b1f248e4cbe33b7f0564d1\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6682e64.png alt=1949a8de23b1f248e4cbe33b7f0564d1\_MD5></a></p><p>Android将硬件加速相关能力封装在hwui组件中，hwui地址：platform/frameworks/base/libs/hwui</p><p>在硬件加速模式下，APP在onDraw中通过Canvas绘制的内容将最终被封装成DisplayList的一个个GrOp绘制命令，然后通过OpenGL或者Vulkan交由GPU进行渲染，随后将结果投送给屏幕显示。而具体是使用OpenGL还是Vulkan是可选择的。早期Android只使用OpenGL，由于Vulkan支持多线程渲染等性能方面的优势，Android逐渐倾向使用Vulkan进行渲染。另外，在哪些维度上进行硬件加速也是可选的：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff66c3c78.png title=9f1bdfab2d0ff4fa5885eae27b92bc62\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff66c3c78.png data-sub-html="<h2>9f1bdfab2d0ff4fa5885eae27b92bc62\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff66c3c78.png alt=9f1bdfab2d0ff4fa5885eae27b92bc62\_MD5></a></p><p>即在整体使用硬件加速的情况下，如果某个View的绘制暂时不支持硬件加速，或者在某些位移动画上为了减少渲染成本，可以动过设置View的layerType = LAYER_TYPE_SOFTWARE来单纯在某个特定View上使用Software Render。</p><p>硬件加速除了利用GPU来加速渲染效率外， 本身在计算渲染范围时相较软件渲染也更加高效，即软件渲染每次更新一个View局部，将使得整个View hierarchy都重新渲染。而硬件加速如只标注有变化的部分，所谓damage area，将绘制指令保存在DisplayList中，如此大大提高渲染速度。</p><h4 class=heading-element id=opengles-vsvulkan><span><strong>OpenGL</strong> <strong>E****S</strong> <strong>VS</strong> <strong>Vulkan</strong></span>
<a href=#opengles-vsvulkan class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>以下为OpenGL ES和Vulkan在Android上发布的版本历史。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a9ad3a.png title=68c2993c0de6ba0211cdda7f25340ccf\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a9ad3a.png data-sub-html="<h2>68c2993c0de6ba0211cdda7f25340ccf\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a9ad3a.png alt=68c2993c0de6ba0211cdda7f25340ccf\_MD5></a></p><p>Vulkan作为一个面向更低级别规范、跨平台的API，可以提供更细粒度的内存管理和资源管理</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6b9be41.png title=186573e3338933bda50cd6a18b0511d5\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6b9be41.png data-sub-html="<h2>186573e3338933bda50cd6a18b0511d5\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6b9be41.png alt=186573e3338933bda50cd6a18b0511d5\_MD5></a></p><p>以下为Vulkan与OpenGL ES的使用率（from GDC 2023 <a href="https://www.youtube.com/watch?v=C7OjI7CpjLw%5c&amp;t=1188s" title="https://www.youtube.com/watch?v=C7OjI7CpjLw\&amp;t=1188s" target=_blank rel="external nofollow noopener noreferrer">https://www.youtube.com/watch?v=C7OjI7CpjLw&amp;t=1188s</a>）：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a83179.png title=ad747698269a2f53cff161306b5fe4ad\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a83179.png data-sub-html="<h2>ad747698269a2f53cff161306b5fe4ad\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a83179.png alt=ad747698269a2f53cff161306b5fe4ad\_MD5></a></p><p>对于未来计划，OpenGL ES将不会再有功能更新，新的功能将只会在Vulkan上支持。因此，Vulkan是未来Android主推的渲染引擎。</p><p>无论是OpenGL还是Vulkan，都需要GPU的支持。例如常见的车载高端芯片高通8155，明确标明了支持: OpenGL ES 3.x、Vulkan<a href=https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/qul7413_sa8155_productbrief_r4.pdf title=https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/qul7413_sa8155_productbrief_r4.pdf target=_blank rel="external nofollow noopener noreferrer">https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/qul7413_sa8155_productbrief_r4.pdf</a></p><h2 class=heading-element id=2-hw-composerhwc2图像合成><span><strong>2. HW</strong> <strong>Composer</strong>**（HWC2）**<strong>图像合成</strong></span>
<a href=#2-hw-composerhwc2%e5%9b%be%e5%83%8f%e5%90%88%e6%88%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>前面提到过，每个window对应一个SF中的Layer，合成（Composition）工作就是将这些Layer进程合并成一个完整的屏幕内容，提交给硬件屏幕显示出来。大概过程如下：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6acc505.png title=f4b02a02af8af825b8014f375ba3d035\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6acc505.png data-sub-html="<h2>f4b02a02af8af825b8014f375ba3d035\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6acc505.png alt=f4b02a02af8af825b8014f375ba3d035\_MD5></a></p><p>这个页面有三个Layer：StatusBar、NavigationBar和中间的APP内容页面，其中可能会有重叠的部分，称为Overlay。Composition的工作就是将这三个Layer合并成一个画面，计算重叠部分的颜色，提交给屏幕显示出来。</p><p>合成的工作发生在渲染后的内容提交给SurfaceFlinger之后。大致流程如下：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6bdee11.png title=3732c69b0236014961750502068f9fa3\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6bdee11.png data-sub-html="<h2>3732c69b0236014961750502068f9fa3\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6bdee11.png alt=3732c69b0236014961750502068f9fa3\_MD5></a></p><p>合成有硬件合成的部分和软件合成的部分。硬件合成除了更高效的同时，可以将合成工作从GPU解放出来，提高GPU效率，节省能耗。嵌入式设备的SOC中，硬件的合成一般由独立的DPU（Display Processing）完成。</p><p>比如高通SA8155这款SOC的布局如下：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6dce145.png title=c78362a611392a99389a11a5b4cd0f18\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6dce145.png data-sub-html="<h2>c78362a611392a99389a11a5b4cd0f18\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6dce145.png alt=c78362a611392a99389a11a5b4cd0f18\_MD5></a></p><p>其中GPU的部分负责渲染，“Dispay Processing”的部分用来处理合成工作。</p><p>由于硬件对合成Layer数量是有限制的，例如高通QCS2290支持4个Layer、AMD有的芯片支持7个等）以及Layer的PixelFormat（比如支持PIXEL_FORMAT_RGBA_8888，不支持YUV）是有限制的，因此在硬件合成之前，如果合成Layer过多或者Format不满足要求，会需要使用GPU先进行一轮软件合成，合并或转换一些Layer的格式。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff683be92.png title=95c82c9537ef99c6eb5ff34b2851a230\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff683be92.png data-sub-html="<h2>95c82c9537ef99c6eb5ff34b2851a230\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff683be92.png alt=95c82c9537ef99c6eb5ff34b2851a230\_MD5></a></p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff68e17e0.png title=50e4bd399b933bc8f5d57898657d7c51\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff68e17e0.png data-sub-html="<h2>50e4bd399b933bc8f5d57898657d7c51\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff68e17e0.png alt=50e4bd399b933bc8f5d57898657d7c51\_MD5></a></p><p>软件合成过程。（Google I/O &lsquo;18）</p><h2 class=heading-element id=4-vsync><span><strong>4. V****SYNC</strong></span>
<a href=#4-vsync class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h4 class=heading-element id=vsync简介><span><strong>VSync简介：</strong></span>
<a href=#vsync%e7%ae%80%e4%bb%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>首先关注两个重要概念：</p><p><strong>refresh</strong> <strong>rate</strong> - 60Hz ：代表每秒钟屏幕可以更新多少次，这一值早期是固定的，依赖于硬件。现代旗舰设备的屏幕都支持多个刷新率，从60Hz~165Hz不等，而且是可以由App层定制刷新率。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6b9b007.png title=cf6858514b95f0902f03bbe8db613e86\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6b9b007.png data-sub-html="<h2>cf6858514b95f0902f03bbe8db613e86\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6b9b007.png alt=cf6858514b95f0902f03bbe8db613e86\_MD5></a></p><p><strong>frame rate</strong>：每秒钟GPU可以绘制多少帧，值越大越好</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff695377f.png title=a4f7b8ed69c217f89e235fc5a76ec2e4\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff695377f.png data-sub-html="<h2>a4f7b8ed69c217f89e235fc5a76ec2e4\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff695377f.png alt=a4f7b8ed69c217f89e235fc5a76ec2e4\_MD5></a></p><p>VSync是一个通用概念，在Linux、PC、移动设备上都有所实现。</p><p>想象一下绘制过程是这样的：GPU绘制数据，将绘制结果投掷给屏幕显示出来。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e1b3a7.png title=a95fdfd2c1c22d3a60530a6af8d83519\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e1b3a7.png data-sub-html="<h2>a95fdfd2c1c22d3a60530a6af8d83519\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e1b3a7.png alt=a95fdfd2c1c22d3a60530a6af8d83519\_MD5></a></p><p>问题是，refresh rate和Frame Rate并不保证是一致的频率，也就是是说GPU渲染的时间并不能保证就正好是16ms（60Hz）内完成的。如果只有一块内存（Frame Buffer）用来交换数据，假如Refresh Rate大于Frame Rate，由于GPU是从上到下写这块内存的，在当屏幕来取数据的时候，GPU刚刚在旧帧基础上写了一半的新帧，此时就会出现图片撕裂问题，如：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e9958d.png title=ac576080581ef956894d564fa665a6eb\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e9958d.png data-sub-html="<h2>ac576080581ef956894d564fa665a6eb\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e9958d.png alt=ac576080581ef956894d564fa665a6eb\_MD5></a></p><p>解决方法是双缓存方案：</p><p>提供Back Buffer和Frame Buffer两个缓存，屏幕始终从Frame Buffer取数据显示，GPU往Back Buffer里写，当GPU完全将数据写好后，再将Back Buffer整个拷贝到Frame Buffer。这样就能保证屏幕每次都取到完整的帧。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6eab452.png title=81f699547147eb8ff9bbdc9daa09fd66\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6eab452.png data-sub-html="<h2>81f699547147eb8ff9bbdc9daa09fd66\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6eab452.png alt=81f699547147eb8ff9bbdc9daa09fd66\_MD5></a></p><p>此时仍有一个问题，如果GPU的Frame Rate大于屏幕的Refresh Rate，那么屏幕再取到下一帧前，可能GPU都写完好几帧了，就会出现丢帧现象。此时就需要VSync：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e6afc0.png title=f004223d535f85cf477b256ad26ac5a4\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e6afc0.png data-sub-html="<h2>f004223d535f85cf477b256ad26ac5a4\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e6afc0.png alt=f004223d535f85cf477b256ad26ac5a4\_MD5></a></p><p>屏幕根据自己的刷新频率，去给上层发送一个VSync信号，GPU在拿到这个VSync信号后，才去绘制。这样就能同步屏幕与上层绘制的节奏了。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e34301.png title=6d6f4f3f715eda915493456e5e71dc38\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e34301.png data-sub-html="<h2>6d6f4f3f715eda915493456e5e71dc38\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6e34301.png alt=6d6f4f3f715eda915493456e5e71dc38\_MD5></a></p><p>如果屏幕的Refresh Rate大于GPU的Frame Rate怎么办？</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6dcb246.png title=2fc3a238855a303d088fa40636620f34\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6dcb246.png data-sub-html="<h2>2fc3a238855a303d088fa40636620f34\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6dcb246.png alt=2fc3a238855a303d088fa40636620f34\_MD5></a></p><p>屏幕将会仍然显示旧帧。比如中间方框的两次刷新，屏幕仍然显示前一次的帧内容。</p><h4 class=heading-element id=android的vsync><span><strong>Android的V****SYNC</strong></span>
<a href=#android%e7%9a%84vsync class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>实际上Android的VSync要复杂得多，主要由SurfaceFlinger负责实现。通过之前的介绍我们知道一帧的绘制过程有APP绘制渲染、SurfaceFlinger合成、Display硬件读取帧缓存显示图片三个阶段，如果每一个阶段都依赖VSync信号来执行，那可能会出现这种情况：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6981a1f.png title=f660323b4324fd57fa1a92a198f83148\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6981a1f.png data-sub-html="<h2>f660323b4324fd57fa1a92a198f83148\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6981a1f.png alt=f660323b4324fd57fa1a92a198f83148\_MD5></a></p><p>也就是说，VSync1的时候APP正在绘制渲染，SF还没有可以合成的东西，所以什么都不做；等到VSync2的时候，Render1的工作已经完成，可以做合成了；VSync3的时候，合成做完了，才可以显示到屏幕上。从绘制渲染到显示经历了3个VSync。面对这种情况，Android对VSync的设计如下：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a50d83.png title=f09c930c8ea399518652623c1a9e5539\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a50d83.png data-sub-html="<h2>f09c930c8ea399518652623c1a9e5539\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6a50d83.png alt=f09c930c8ea399518652623c1a9e5539\_MD5></a></p><p>即有三种信号</p><p>HW_VSYNC_[ID]：由底层硬件按Refresh Rate的频率发出，一般为60Hz、90Hz、120H等等，随后会通过HWC通知给SurfaceFlinger。</p><p>VSYNC-app：SurfaceFlinger通知给上层应用的VSYNC，用于控制和驱动应用的绘制渲染。</p><p>VSYNC-sf:通知给SurfaceFlinger自身的，用于合成Layer的信号。</p><p>VSYNC-app和VSYNC-sf相对于HW_VSYNC_[ID]，并不是同步发送的，而是有一定的延迟，称为相位差。从HW_VSYNC_[ID]到VSYNC-app发出的时间差称为app phase，HW_VSYNC_[ID]到VSYNC-sf发出的时间差称为sf phase。这种设计的好处是，如果在同一个VSync周期内，经sf phase后在执行合成时恰好前一步的Render完成了，就可在一个周期完成两步，而不用非得等下一个VSync。</p><p>另外，Android并非直接把硬件的HW_VSYNC_[ID]信号直接分发给应用和SurfaceFlinger，而是通过先收集HW_VSYNC_[ID]样本，再根据屏幕Refresh Rate、预先配置的相位差等信息，经过计算后模拟出来的VSYNC-app和VSYNC-sf。</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff69aa46e.png title=e3eb9556840a382cceecdea3d73af1f8\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff69aa46e.png data-sub-html="<h2>e3eb9556840a382cceecdea3d73af1f8\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff69aa46e.png alt=e3eb9556840a382cceecdea3d73af1f8\_MD5></a></p><p>由于只需要一定的硬件VSync样本后便可以模拟出预期的VSYNC-app和VSYNC-sf，因此并不需要一直接收HW_VSYNC_[ID]信号，在收到足够的样本数后（在Android 14中为6个）就可以关闭硬件VSync的接收。在每次将合成数据提交给屏幕后，会返回一个硬件VSync时间戳（PresentFence），此时SF会对比当前模拟VSync与硬件VSync是否误差过大，如果过大，会重新打开硬件VSync收集样本重新计算。另外，每次终端应用主动请求VSync时，也会判断前后两次模拟的VSync时间差是否超过750ms，如果是则重新请求打开硬件VSync。在systrace上硬件VSync打开的TAG是HW_VSYNC_ON_[ID]。</p><p>参考资料：<a href=https://source.android.com/docs/core/graphics/implement-vsync title=https://source.android.com/docs/core/graphics/implement-vsync target=_blank rel="external nofollow noopener noreferrer">https://source.android.com/docs/core/graphics/implement-vsync</a></p><h4 class=heading-element id=可变刷新率><span><strong>可变刷新率</strong></span>
<a href=#%e5%8f%af%e5%8f%98%e5%88%b7%e6%96%b0%e7%8e%87 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>现代旗舰机屏幕的刷新率是可变的，比如Pixel 5：</p><p><a class=lightgallery href=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6c1761b.png title=b99c51dcd12ba54836fa82d9a8d7eeaf\_MD5 data-thumbnail=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6c1761b.png data-sub-html="<h2>b99c51dcd12ba54836fa82d9a8d7eeaf\_MD5</h2>"><img loading=lazy src=https://picgo.myjojo.fun:666/i/2024/10/11/6708ff6c1761b.png alt=b99c51dcd12ba54836fa82d9a8d7eeaf\_MD5></a></p><p>可以看到，该屏幕是支持60Hz、90Hz两种刷新率的。</p><p>而且应用层也可以在应用级别、窗口级别指定具体的刷新率。在经过应用层指定后，最终的刷新率并不一定是指定的值，而是经过SurfaceFlinger综合计算后得出。具体见<a href=https://developer.android.com/media/optimize/performance/frame-rate title=https://developer.android.com/media/optimize/performance/frame-rate target=_blank rel="external nofollow noopener noreferrer">https://developer.android.com/media/optimize/performance/frame-rate</a></p></div><div class=collection-card><div class="collection-title text-secondary">收录于 <a href=/collections/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/><i class="fa-solid fa-layer-group fa-fw" aria-hidden=true></i> <span>合集・图形显示</span></span></a> 43</div><div class=collection-nav><a href=/posts/surfacecontrol%E4%B9%8Btransaction%E4%BA%8B%E7%89%A9%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-android-framework%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91-csdn%E5%8D%9A%E5%AE%A2/ class=collection-nav-item rel=prev title="SurfaceControl之Transaction事物深入剖析-Android Framework实战开发-CSDN博客"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i><span>SurfaceControl之Transaction事物深入剖析-Android Framework实战开发-CSDN博客</span>
</a><a href=/posts/android-surfaceflinger-csdn%E5%8D%9A%E5%AE%A2/ class=collection-nav-item rel=next title="Android SurfaceFlinger-CSDN博客"><span>Android SurfaceFlinger-CSDN博客</span><i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-11-05 01:33:59">更新于 2024-11-05&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://huang8604.github.io/posts/android-14-%E7%BB%98%E5%88%B6%E4%BD%93%E7%B3%BB-%E6%A6%82%E8%A7%88_blastbufferqueue-csdn%E5%8D%9A%E5%AE%A2/ data-title="Android 14 - 绘制体系 - 概览_blastbufferqueue-CSDN博客"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/clippings/ class=post-tag title="标签 - Clippings">Clippings</a><a href=/tags/%E8%BD%AC%E8%BD%BD/ class=post-tag title="标签 - 转载">转载</a><a href=/tags/blog/ class=post-tag title="标签 - Blog">Blog</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/android-surfaceflinger-csdn%E5%8D%9A%E5%AE%A2/ class=post-nav-item rel=prev title="Android SurfaceFlinger-CSDN博客"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Android SurfaceFlinger-CSDN博客</a><a href=/posts/%E6%B1%87%E6%80%BBbinder%E7%9B%B8%E5%85%B3%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/ class=post-nav-item rel=next title=汇总binder相关一些常见面试题-安卓系统常见面试题-CSDN博客>汇总binder相关一些常见面试题-安卓系统常见面试题-CSDN博客<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=static></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=huang8604/huang8604.github.io data-repo-id=R_kgDOMx3bEg data-category=Announcements data-category-id=DIC_kwDOMx3bEs4CigIp data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.152.2"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.20"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/huang8604 target=_blank rel="external nofollow noopener noreferrer">wentao</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:199},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark",lightTheme:"light",origin:"https://giscus.app"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/search.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},version:"v0.3.20"}</script><script src=/js/theme.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>