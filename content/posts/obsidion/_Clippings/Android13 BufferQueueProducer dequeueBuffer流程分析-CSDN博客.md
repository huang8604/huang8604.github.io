---
title: Android13 BufferQueueProducer dequeueBuffer流程分析-CSDN博客
created: 2024-09-26
tags:
  - clippings
  - 转载
  - blog
collections:
  - 图形显示
date: 2024-09-26T07:18:32.230Z
lastmod: 2024-09-26T07:18:49.042Z
---
BufferQueueProducer的dequeueBuffer方法是Android系统中用于从BufferQueue中获取可用的缓冲区的方法。BufferQueue是一个用于在不同线程之间传递图像数据的队列，它通常用于图像渲染和[视频编解码](https://so.csdn.net/so/search?q=%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81\&spm=1001.2101.3001.7020)等场景。

dequeueBuffer方法的作用是从BufferQueue中[获取一个](https://so.csdn.net/so/search?q=%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA\&spm=1001.2101.3001.7020)可用的缓冲区，并返回该缓冲区的索引。如果没有可用的缓冲区，则该方法会阻塞，直到有可用的缓冲区为止。

在调用dequeueBuffer方法之前，需要先通过BufferQueue的getBufferCount方法获取可用缓冲区的数量。然后，通过dequeueBuffer方法获取一个可用的缓冲区，并将其索引作为参数传递给其他相关的方法，如图像渲染或视频编解码等。

代码如下：

```cpp
class BufferQueueProducer : public BnGraphicBufferProducer {status_t BufferQueueProducer::dequeueBuffer(int* outSlot, sp<android::Fence>* outFence,                                            uint32_t width, uint32_t height, PixelFormat format,                                            uint64_t usage, uint64_t* outBufferAge,                                            FrameEventHistoryDelta* outTimestamps) {ATRACE_CALL();    { std::lock_guard<std::mutex> lock(mCore->mMutex);        mConsumerName = mCore->mConsumerName;if (mCore->mIsAbandoned) {BQ_LOGE("dequeueBuffer: BufferQueue has been abandoned");return NO_INIT;        }if (mCore->mConnectedApi == BufferQueueCore::NO_CONNECTED_API) {BQ_LOGE("dequeueBuffer: BufferQueue has no connected producer");return NO_INIT;        }    } BQ_LOGV("dequeueBuffer: w=%u h=%u format=%#x, usage=%#" PRIx64, width, height, format, usage);if ((width && !height) || (!width && height)) {BQ_LOGE("dequeueBuffer: invalid size: w=%u h=%u", width, height);return BAD_VALUE;    }status_t returnFlags = NO_ERROR;    EGLDisplay eglDisplay = EGL_NO_DISPLAY;    EGLSyncKHR eglFence = EGL_NO_SYNC_KHR;bool attachedByConsumer = false;    { std::unique_lock<std::mutex> lock(mCore->mMutex);if (mCore->mFreeBuffers.empty() && mCore->mIsAllocating) {            mDequeueWaitingForAllocation = true;            mCore->waitWhileAllocatingLocked(lock);            mDequeueWaitingForAllocation = false;            mDequeueWaitingForAllocationCondition.notify_all();        }if (format == 0) {            format = mCore->mDefaultBufferFormat;        }        usage |= mCore->mConsumerUsageBits;const bool useDefaultSize = !width && !height;if (useDefaultSize) {            width = mCore->mDefaultWidth;            height = mCore->mDefaultHeight;if (mCore->mAutoPrerotation &&                (mCore->mTransformHintInUse & NATIVE_WINDOW_TRANSFORM_ROT_90)) {                std::swap(width, height);            }        }int found = BufferItem::INVALID_BUFFER_SLOT;while (found == BufferItem::INVALID_BUFFER_SLOT) {status_t status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue, lock, &found);if (status != NO_ERROR) {return status;            }if (found == BufferQueueCore::INVALID_BUFFER_SLOT) {BQ_LOGE("dequeueBuffer: no available buffer slots");return -EBUSY;            }const sp<GraphicBuffer>& buffer(mSlots[found].mGraphicBuffer);if (!mCore->mAllowAllocation) {if (buffer->needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) { if (mCore->mSharedBufferSlot == found) {BQ_LOGE("dequeueBuffer: cannot re-allocate a sharedbuffer");return BAD_VALUE;                    }                    mCore->mFreeSlots.insert(found);                    mCore->clearBufferSlotLocked(found);                    found = BufferItem::INVALID_BUFFER_SLOT;continue;                }            }        }const sp<GraphicBuffer>& buffer(mSlots[found].mGraphicBuffer);if (mCore->mSharedBufferSlot == found &&                buffer->needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) {BQ_LOGE("dequeueBuffer: cannot re-allocate a shared""buffer");return BAD_VALUE;        }if (mCore->mSharedBufferSlot != found) {            mCore->mActiveBuffers.insert(found);        }        *outSlot = found;ATRACE_BUFFER_INDEX(found);        attachedByConsumer = mSlots[found].mNeedsReallocation;        mSlots[found].mNeedsReallocation = false;        mSlots[found].mBufferState.dequeue();if ((buffer == nullptr) ||                buffer->needsReallocation(width, height, format, BQ_LAYER_COUNT, usage))        {            mSlots[found].mAcquireCalled = false;            mSlots[found].mGraphicBuffer = nullptr;            mSlots[found].mRequestBufferCalled = false;            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;            mSlots[found].mFence = Fence::NO_FENCE;            mCore->mBufferAge = 0;            mCore->mIsAllocating = true;            returnFlags |= BUFFER_NEEDS_REALLOCATION;         } else {            mCore->mBufferAge = mCore->mFrameCounter + 1 - mSlots[found].mFrameNumber;        }BQ_LOGV("dequeueBuffer: setting buffer age to %" PRIu64,                mCore->mBufferAge);if (CC_UNLIKELY(mSlots[found].mFence == nullptr)) {BQ_LOGE("dequeueBuffer: about to return a NULL fence - ""slot=%d w=%d h=%d format=%u",                    found, buffer->width, buffer->height, buffer->format);        }        eglDisplay = mSlots[found].mEglDisplay;        eglFence = mSlots[found].mEglFence;        *outFence = (mCore->mSharedBufferMode &&                mCore->mSharedBufferSlot == found) ?                Fence::NO_FENCE : mSlots[found].mFence;        mSlots[found].mEglFence = EGL_NO_SYNC_KHR;        mSlots[found].mFence = Fence::NO_FENCE;if (mCore->mSharedBufferMode && mCore->mSharedBufferSlot ==                BufferQueueCore::INVALID_BUFFER_SLOT) {            mCore->mSharedBufferSlot = found;            mSlots[found].mBufferState.mShared = true;        }if (!(returnFlags & BUFFER_NEEDS_REALLOCATION)) {if (mCore->mConsumerListener != nullptr) {                mCore->mConsumerListener->onFrameDequeued(mSlots[*outSlot].mGraphicBuffer->getId());            }        }    } if (returnFlags & BUFFER_NEEDS_REALLOCATION) {BQ_LOGV("dequeueBuffer: allocating a new buffer for slot %d", *outSlot);        sp<GraphicBuffer> graphicBuffer = new GraphicBuffer(                width, height, format, BQ_LAYER_COUNT, usage,                {mConsumerName.string(), mConsumerName.size()});status_t error = graphicBuffer->initCheck();        { std::lock_guard<std::mutex> lock(mCore->mMutex);if (error == NO_ERROR && !mCore->mIsAbandoned) {                graphicBuffer->setGenerationNumber(mCore->mGenerationNumber);                mSlots[*outSlot].mGraphicBuffer = graphicBuffer; if (mCore->mConsumerListener != nullptr) {                    mCore->mConsumerListener->onFrameDequeued(                            mSlots[*outSlot].mGraphicBuffer->getId());                }            }            mCore->mIsAllocating = false;            mCore->mIsAllocatingCondition.notify_all();if (error != NO_ERROR) {                mCore->mFreeSlots.insert(*outSlot);                mCore->clearBufferSlotLocked(*outSlot);BQ_LOGE("dequeueBuffer: createGraphicBuffer failed");return error;            }if (mCore->mIsAbandoned) {                mCore->mFreeSlots.insert(*outSlot);                mCore->clearBufferSlotLocked(*outSlot);BQ_LOGE("dequeueBuffer: BufferQueue has been abandoned");return NO_INIT;            }VALIDATE_CONSISTENCY();        }     }if (attachedByConsumer) {        returnFlags |= BUFFER_NEEDS_REALLOCATION;    }if (eglFence != EGL_NO_SYNC_KHR) {        EGLint result = eglClientWaitSyncKHR(eglDisplay, eglFence, 0,1000000000);if (result == EGL_FALSE) {BQ_LOGE("dequeueBuffer: error %#x waiting for fence",eglGetError());        } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {BQ_LOGE("dequeueBuffer: timeout waiting for fence");        }eglDestroySyncKHR(eglDisplay, eglFence);    }BQ_LOGV("dequeueBuffer: returning slot=%d/%" PRIu64 " buf=%p flags=%#x",            *outSlot,            mSlots[*outSlot].mFrameNumber,            mSlots[*outSlot].mGraphicBuffer->handle, returnFlags);if (outBufferAge) {        *outBufferAge = mCore->mBufferAge;    }addAndGetFrameTimestamps(nullptr, outTimestamps);return returnFlags; }}
```

## new GraphicBuffer

通过new的方式创建GraphicBuffer对象：

[Android13 GraphicBuffer 创建流程-CSDN博客](https://blog.csdn.net/liuning1985622/article/details/138467173?spm=1001.2014.3001.5502 "Android13 GraphicBuffer 创建流程-CSDN博客")
